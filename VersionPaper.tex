\documentclass[conference]{IEEEtran}

\hyphenation{op-tical net-works semi-conduc-tor}

\input{macros}

\begin{document}

\title{A study on version number practices}

\author{\IEEEauthorblockN{Sergii Shmarkatiuk, 
Kendall Bailey and
Danny Dig
}}

%\numberofauthors{1} %  in this sample file, there are a *total*
%% of EIGHT authors. SIX appear on the 'first-page' (for formatting
%% reasons) and the remaining two appear in the \additionalauthors section.
%%
%\author{
%% 1st. author
%\alignauthor
%Sergii Shmarkatiuk, Kendall Bailey, Danny Dig\\
%       \affaddr{Oregon State University}\\
%       \email{\{shmarkas,baileken,digd\}@eecs.oregonstate.edu}
%}

\maketitle
\begin{abstract}
 TODO Abstract
 TODO Category
 \end{abstract}


\IEEEpeerreviewmaketitle

\section{Introduction}
TODO Last



\section{Experimental Setup}

\subsection{Data Corpus}

\par To answer our research questions we gathered information about version numbering from both open source and proprietary projects, totaling  \TotalNumProjects projects. When selecting projects to add to the corpus we chose
projects that are (i) mature and well-known, and (ii) representative. Our corpus spans the areas of software development tools, operating systems, games, programming languages, desktop applications, productivity tools, libraries and frameworks, etc. 
Our requirements for members of the corpus also included easily accessible version information as well as adequate documentation.

For open source projects we drew data from both Github and SourceForge because previous studies \cite{} have shown that git and svn, the backbone of Github and SourceForge respectively, are the most widely used version control systems. In addition to this, both systems contain rich history information about tags and version numbers. To retrieve the version history of each project we used the \code{git tag} and \code{svn list} 
%svn://svn.code.sf.net/p/\$project\_name/code/tags}  
commands and stored the output of each command for later analysis.

For proprietary projects, sometimes the version numbers from the producer website
were incomplete or disorganized. Thus we recovered the missing information from third party websites.
To extract version numbers, we combined information from readily available producer sources such as release notes, documentation, and download archives
with information from third party websites such as wikis, user forums, press releases.
When we had to use multiple sources, we merged the version numbers into a single set per project. During the merge we removed duplicates between the documents, but did not remove duplicates when they existed in the same document, e.g., when two different download archives had the same version number.

Table \ref{tab:ProjectsCorpus} lists the names of the projects in our corpus. For each project we also tabulate information such as age, size, number of versions, \TODO{describe the columns}.

\subsection{Data Parsing}

 Version numbering patterns can vary widely between projects, thus making comparison difficult. 
To counter this, we defined common patterns across different numbering approaches. 

We defined a version number as a composition of the following parts: 
prefix, first version compound, second
 version compound, third version compound, fourth version compound, suffix label, and suffix number. 

Additionally, our definition discards delimiters (e.g., period, underscore, space, dash). When the version number contains textual compounds (e.g., \code{a}, \code{b}, \code{c}) we convert them into a numerical representation such that we can compute metrics even for such compounds. 

Table \ref{table:exampleVCs} shows examples of version numbers before-and-after 
our parsing.
 
 \begin{table*}[t]
 \begin{center}
\begin{tabular}{| *{8}{l|}}
\hline
Version Number & Prefix & 1 VC & 2 VC & 3 VC & 4 VC  & Suffix Label & Suffix Number \\ \hline
v\_3.4.5\_p34 & v\_ & 3 & 4 & 5 & & p & 34 \\
R 2.11.1 RC & R & 2 & 11 & 1 & & RC & \\
5.6.32.78 &  & 5 & 6 & 32 & 78 & & \\ \hline

\end{tabular}
\end{center}
\caption{Numeric version compounds are bolded. }
\label{table:exampleVCs}
\end{table*}
 
 
 
 To process and analyze the collected version number data we wrote a script that parses the data into our format. 


%TODO link to github!
%TODO Editting stopped here

% In order to ensure that we covered most common patterns of version numbering that appear in the dataset, we created a test suite with common parsing scenarios (TODO: do we need to list common scenarios? ). Test cases can be found in github repository [LINK] of our project.  



% In order to ensure that we covered most common patterns of version numbering that appear in the dataset, we created a test suite with common parsing scenarios (TODO: do we need to list common scenarios? ). Test cases can be found in github repository [LINK] of our project.  


%\par Different projects use different version numbering practices. 
%In order to standardize version numbering patterns to be able to parse corresponding versions that appear in different data sources, we have come up with a convention for version number structure. 
%Convention includes following parts of version number: prefix, first version compound, second version compound, third version compound, fourth version compound, suffix label, suffix number. 
%Script that parses version numbers allows for following separators between different version number compounds: '.' (period), '-' (dash), '\_'(underscore), ' ' (space). 
%You can find examples of version number parsing results in Table \ref{table:exampleVCs}. Also we distinct between numeric version compounds and textual version compound. Numeric version compounds appear in Table \ref{table:exampleVCs} in bold.


\section{State of the Practice}

\TODO{This section}

Given a version number MAJOR.MINOR.PATCH, increment the:

MAJOR version when you make incompatible API changes,
MINOR version when you add functionality in a backwards-compatible manner, and
PATCH version when you make backwards-compatible bug fixes.
Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format.

\section{Metrics}

\TODO{Why inconsistency is bad? Because it breaks existing assumptions.} 
We define inconsistency in software version numbering as an availability of choices for assigning new version number that breaks existing version numbering patterns. 
For example, if software development team released versions 1.0, 1.1 and 1.2, then, following the establish pattern, the next expected version of upcoming release would be 1.3. 
However,  the software development team in this example decided to assign version 2.0 to the next release instead.
%\TODO{Sometimes software development team decides to assign version 2.0 instead or assigning version 1.3}. 
If there is no communication between development team and external groups, deviating from the established version numbering pattern breaks the assumptions of other groups that rely on the software, such as the software testing team.
%Because the next version increases from 1.2 to 2.0, software testers and other teams dependent upon the software will make assumptions based on the broken broken pattern in the version numbering.
%This jump from 1.2 to 2.0 will break assumptions of software testing team about upcoming release. 
%In this particular scenario testers might make assumptions not only about version numbers. 

Increasing a version compound on the left such as from 1.2 to 2.0 usually indicates that the new release includes some important or large scale changes. Because the version number increased to 2.0 instead of 1.3 in the above example,  the software testing team suddenly expects to perform additional work to accommodate the supposed larger changes (e.g. a large number of features to be tested, new test-suites to be created, test-plan to be updated, etc).
%\feedback{you lost me after this. What if there was a big change and the tester did need to do a lot of work?} 
Thus, a simple change of version number might lead to confusion and misunderstanding between members of software team.
%This is a simple example of ..... 

\TODO{To summarize, inconsistent version numbers have potential to break assumptions about established software development processes. }

We distinguish between different degrees (severities) of inconsistency depending on how many choices for change of version number are available for given project. The following examples illustrate ideal scenarios of version numbering histories according to the state of the practice, described in Section\ref{secState}.\\

\TODO{Example Diagram}

\MyParagraph{Example 1} As described above, a software team working on a project with existing versions 1.0, 1.1, 1.2 has two possible choices of assigning new version number to upcoming release (1.3 and 2.0). Number of choices differs depending on certain properties of version histories. In this situation, the software development team is using only two version compounds. \\
% The first such property is \textbf{number of version compounds}. 

\MyParagraph{Example 2} A software team working on the project with existing versions 1.0.0, 1.0.1, 1.0.2 has three possible choices of assigning new version number to upcoming release (1.0.3, 1.1.0 and 2.0.0). In Example 2, the software development team is using three version compounds. \\

%Second property that defines number of possible choices for new version numbers is \textbf{number of "locked in" versions}. 

\MyParagraph{Example 3} A software team  is working on a project with a list of existing versions 1.0, 1.1, 1.2, 2.0, 2.1, 3.0 would have three choices (1.3, 2.2, 3.1). This case is different from Example 1 and Example 2 because the software team has the option to release one update for either the latest version or an older version.  Note that choice of selecting version 2.0 for release following 1.2 is unavailable because version 2.0 already exists. Choice of selecting version 3.0 for release following 2.1 is also unavailable because version 3.0 already exists. \\

\MyParagraph{Example 4}  A software team  is working on a project with a list of existing versions 1.0.0, 1.0.1, 1.0.2, 2.0.0, 2.1.0, 3.0.0 would have the choices 1.0.3, 1.1.0, 2.0.1, 2.1.1, 2.2.0, 3.0.1, 3.1.0, 4.0.0 for a total of eight possible choices. In this case, software team has the option to use  three version compounds and the option to build off of older releases. \\

\TODO{Why these are valid examples and the state of the practice}
In Example 3 and 4 the inclusion of building on older versions stems from the need to support older versions of software for users that are unable or unwilling to use the latest release.

\TODO{Explain \# choices, then introduce metatrees}

In looking at ideal examples of the state of the practice, we were able to identify a cause for an increase in the \choices based on the list of existing versions. 
As a result we developed an abstraction called a metatree. The concept of a metatree allows us to calculate the \choices for an arbitrary list of existing versions.
We construct metatree from version sets. We represent the list of versions 1.0, 1.1, 1.2, $\dots$, 1.N and the list of versions 2.0, 2.1, $\dots$, 2.N as version sets 1.x and 2.x, respectively. 
This can be expanded to include additional version compounds. 
For example 1.x.x represents the set of version sets 1.0.x (including 1.0.0, 1.0.1, 1.0.2, $\dots$, 1.0.N), 1.1.x (including 1.1.0, 1.1.1, 1.1.2, $\dots$, 1.1.N),  $\dots$, 1.M.x (including 1.M.0, 1.M.1, 1.M.2, $\dots$, 1.M.N). As shown in Diagram \ref{diaVersionSet}.
Finally, x.x.x represents the super set of version sets in the above example, including sets of version sets 1.x.x, 2.x.x, $\dots$, K.x.x.
\TODO{Version Set Diagram}
Using our version set notation, we establish parent-child relationships between different version sets. For example, version set 1.x.x is the parent to version sets 1.0.x, 1.1.x, $\dots$, 1.M.x.  Similarly we consider x.x.x to be the parent for version sets 1.x.x, 2.x.x, $\dots$, K.x.x.  

We construct metatrees using the parent-child relationships of the version sets. 
\TODO{MetaTrees Diagram (one for each of the 4 examples before)}

%In this case we consider set of versions 1.x (1.0, 1.1, 1.2) and 2.x (2.0, 2.1) to be "locked in" because one of the choices for new version numbers is unavailable.

In order to analyze the degree of inconsistency in version numbers, we define 
a set of metrics that measure common features of version numbers sequences. Different metrics establish typical cases that introduce additional choices for version numbering. 
 
 \TODO{How to determine the number of choices}
 
 \TODO{END OF DAY: 1. Version history to metatree mapping. 2. Explain throwing away the latest metatree nodes and why and how metatrees affect choices. 3. Explain placeholder. 4. explanation of metrics in terms of metatrees. 5. Party like its 1999. }
 
\TODO{Use the Latex command for definition:} A jump is defined by two consecutively released versions when a version compound increases by more than one.
For example, one project where version 1.0.25 is followed immediately by version 1.0.28 represents one jump in the third version compound. This jump's size is 3.

Jumps represent inconsistencies in version numbering and can cause confusion.
 
%\begin{itemize}
\MyParagraph{\textbf{Number of jumps}}.  For each version compound of a project, this metric counts the total number of jumps across all versions. For example, in a project where one jump happens from version 1.0.25 to 1.0.28, and another jump happens from 1.0.34 to 1.0.40 will register as two jumps in the third version compound.\\

\MyParagraph{\textbf{Sum of jumps}}.  For each version compound of a project, this metric counts the sum of all sizes of jumps within that compound. 
In the example above, the length of jump on the third version compound is 
9 ( 3 + 6). Whereas the previous metric records whether jumps occurred, this metric records the severity of the jumps. \\
 
\MyParagraph{\textbf{Average size of jumps}}. For each version compound of a project, this metric calculates average of  jump sizes within that compound. For the example above, the average jump size for the third version compound is 4.5 ( ( 3 + 6 ) / 2)
 
 %\textbf{List of jumps.} We consider every change in numeric version compound to be a jump if difference between version compound values appear to be greater than 1. Examples: 1 to 3, 5 to 10. 
%\begin{equation}
%VC_{2} - VC_{1} > 1
%\end{equation}

%\end{itemize}

%We collect length of each jump for further analysis. For example list of jumps for third version compound for array of version numbers [1.0.2, 1.0.3, 1.0.5, 1.0.6, 1.0.7, 1.0.10] would be [2, 3]. 

\TODO{Definition} An empty jump is defined by two consecutively released versions containing a different number of version compounds. 
For example, one project where version 1.0.25 is followed immediately by version 1.1 represents an empty jump in third version compound, later in this project another empty jump happens from version 1.3 to 1.3.1. We do not distinguish between adding or removing version compounds because either expanding or shrinking the version number demonstrates a lack of consistency. \TODO{address textual stuff?} \\

%\begin{itemize}

\MyParagraph{\textbf{Number of empty jumps}}. For each version compound of a project, this metric counts the sum of all occurrences of empty jumps throughout each version compound.
For example, both 1.0.25 to 1.1 and 1.3 to 1.3.1 are empty jumps in third version compound \feedback{(an empty jump in the second and third version compounds, respectively | two empty jumps in the third compound)}. \\
%for each numeric version compound. We consider change of numeric version compound to be an empty jump if empty value substitutes numeric value of version compound. For example, there is an empty jump of fourth version compound for the pair of version numbers [1.0.2.4, 1.0.3]. \\

%
%\begin{equation}
%\begin{split}
%isNumeric(VC_{1}) \&\& isEmpty(VC_{2})  || \\  
%isNumeric(VC_{2}) \&\& isEmpty(VC_{1})
%\end{split}
%\end{equation}

 
\MyParagraph{\textbf{Instances of Megalomania}}. Megalomania is defined as electing to increment a version compound to the left of the rightmost version compound when moving to the next version number.
For example a developer might think about two ways of incrementing version 1.0 if he or she needs to come up with a version number for the next release.
 As far as most of the existing conventions describe [LINKS], first way is to assign version 1.1 to new release. Second way is to assign version 2.0. Note that second approach uses increment of first version compound instead of incrementing rightmost version compound, this is megalomania. 

Developers introduce potential for megalomania by using more than one version compound in the version number. As a result, there are several ways of incrementing version numbers in cases when version numbers consist of more than one version compound. We use instances of megalomania as indicators of potential for arbitrary decisions related to version numbering. 
% \feedback{Why is this important?}
%We consider this case of assigning next version number (incrementing version compounds on the left side instead of rightmost version compound) to be instance of megalomania. 

In most general case, instances of megalomania include increment of version number than involves increment of other version compounds than the rightmost version compound.

Other examples of megalomania: $$ 1.0.2 \rightarrow 2.0.0 \texttt{, } 1.4.5 \rightarrow 1.5.0 $$

\MyParagraph{Severity of Megalomania} 
\TODO{Define severity} 
There is a difference between change from 1.0 to 2.0 and change from 1.0.0 to 2.0.0 . Why? 

There are N-1 possible cases of assigning new version to the version number with N numeric version compounds. We distinct between different ways of assigning version numbers depending on position of incremented numeric version compound. 

For example we consider change of version 1.0 to 2.0 to be megalomania of severity 1, 1.0.0 to 2.0.0 to be megalomania of severity 2 and change of version 1.0.0.0 to 2.0.0.0 to be megalomania of severity 3.

change of version 1.0.4\_p34 to 1.1.0 to be megalomania of severity 2, etc. In most general case, we consider changing 1st numeric version compound in version with N numeric version compounds to be megalomania of severity N-1, 2nd numeric version compound in version with N numeric version compounds to be megalomania of severity N-2, and so on. 

We collect information about megalomania severity as another metric. For example, list of megalomania severities for list of versions [1.0.0, 1.0.1, 1.0.2, 1.1.0, 1.1.1, 1.2.0, 1.2.1, 2.0.0] would be [1,1,2].

We calculated metrics both for each version compound and aggregated values to represent metrics for  version number.
%\end{itemize}

\TODO{Make the next paragraph flow with the rest}
Our script collects metrics by traversing list of version numbers pair by pair. Single value for each metric takes a pair of version numbers [$VN_{1}$, $VN_{2}$] to produce metric value.

\section{Analysis}

\begin{itemize}
\item RQ1: OSS vs Proprietary
\item RQ2: Projects of different sizes
\item RQ3: Age of different projects
\item RQ4: Dev tools vs other applications
\item RQ5: SDKs vs other applications 
\end{itemize}


\section{Implications}

\section{Threats to Validity}

 The proprietary data may be incomplete because we only harvested information that the distributor chose to display online which could contribute to additional jumps for artifacts that were never made public. Conversely, enterprises may shield the general from the burden of intermediate builds by only displaying clean, sequential versions on their websites and in their documentation which could skew the results of our analysis.





\section{Conclusions}


\section*{Acknowledgments}

The authors would like to thank...

%
% The following two commands are all you need in the
% initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
\bibliographystyle{IEEEtran}
\bibliography{bibliography}  % sigproc.bib is the name of the Bibliography in this case

\end{document}
