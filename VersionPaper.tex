\documentclass[conference]{IEEEtran}

\hyphenation{op-tical net-works semi-conduc-tor}

\input{macros}
\usepackage{dirtree}
\usepackage{tabularx}

\begin{document}

\title{A study on version number practices}

\author{\IEEEauthorblockN{Sergii Shmarkatiuk, 
Kendall Bailey and
Danny Dig
}}

%\numberofauthors{1} %  in this sample file, there are a *total*
%% of EIGHT authors. SIX appear on the 'first-page' (for formatting
%% reasons) and the remaining two appear in the \additionalauthors section.
%%
%\author{
%% 1st. author
%\alignauthor
%Sergii Shmarkatiuk, Kendall Bailey, Danny Dig\\
%       \affaddr{Oregon State University}\\
%       \email{\{shmarkas,baileken,digd\}@eecs.oregonstate.edu}
%}

\maketitle
\begin{abstract}
 TODO Abstract
 TODO Category
 \end{abstract}


\IEEEpeerreviewmaketitle

\section{Introduction}
TODO Last



\section{Experimental Setup}

\subsection{Data Corpus}

\par To answer our research questions we gathered information about version numbering from both open source and proprietary projects, totaling  \TotalNumProjects projects. When selecting projects to add to the corpus we chose
projects that are (i) mature and well-known, and (ii) representative. Our corpus spans the areas of software development tools, operating systems, games, programming languages, desktop applications, productivity tools, libraries and frameworks, etc. 
Our requirements for members of the corpus also included easily accessible version information as well as adequate documentation.

For open source projects we drew data from both Github and SourceForge because previous studies \cite{} have shown that git and svn, the backbone of Github and SourceForge respectively, are the most widely used version control systems. In addition to this, both systems contain rich history information about tags and version numbers. To retrieve the version history of each project we used the \code{git tag} and \code{svn list} 
%svn://svn.code.sf.net/p/\$project\_name/code/tags}  
commands and stored the output of each command for later analysis.

For proprietary projects, sometimes the version numbers from the producer website
were incomplete or disorganized. Thus we recovered the missing information from third party websites.
To extract version numbers, we combined information from readily available producer sources such as release notes, documentation, and download archives
with information from third party websites such as wikis, user forums, press releases.
When we had to use multiple sources, we merged the version numbers into a single set per project. During the merge we removed duplicates between the documents, but did not remove duplicates when they existed in the same document, e.g., when two different download archives had the same version number.

Table \ref{tab:ProjectsCorpus} lists the names of the projects in our corpus. For each project we also tabulate information such as age, size, number of versions, \TODO{describe the columns}.

\subsection{Data Parsing}

 Version numbering patterns can vary widely between projects, thus making comparison difficult. 
To counter this, we defined common patterns across different numbering approaches. 

We defined a version number as a composition of the following parts: 
prefix, first version compound, second
 version compound, third version compound, fourth version compound, suffix label, and suffix number. 

Additionally, our definition discards delimiters (e.g., period, underscore, space, dash). When the version number contains textual compounds (e.g., \code{a}, \code{b}, \code{c}) we convert them into a numerical representation such that we can compute metrics even for such compounds. 

Table \ref{table:exampleVCs} shows examples of version numbers before-and-after 
our parsing.
 
 \begin{table*}[t]
 \begin{center}
\begin{tabular}{| *{8}{l|}}
\hline
Version Number & Prefix & 1 VC & 2 VC & 3 VC & 4 VC  & Suffix Label & Suffix Number \\ \hline
v\_3.4.5\_p34 & v\_ & 3 & 4 & 5 & & p & 34 \\
R 2.11.1 RC & R & 2 & 11 & 1 & & RC & \\
5.6.32.78 &  & 5 & 6 & 32 & 78 & & \\ \hline

\end{tabular}
\end{center}
\caption{Numeric version compounds are bolded. }
\label{table:exampleVCs}
\end{table*}
 
 
 
 To process and analyze the collected version number data we wrote a script that parses the data into our format. 


%TODO link to github!
%TODO Editting stopped here

% In order to ensure that we covered most common patterns of version numbering that appear in the dataset, we created a test suite with common parsing scenarios (TODO: do we need to list common scenarios? ). Test cases can be found in github repository [LINK] of our project.  



% In order to ensure that we covered most common patterns of version numbering that appear in the dataset, we created a test suite with common parsing scenarios (TODO: do we need to list common scenarios? ). Test cases can be found in github repository [LINK] of our project.  


%\par Different projects use different version numbering practices. 
%In order to standardize version numbering patterns to be able to parse corresponding versions that appear in different data sources, we have come up with a convention for version number structure. 
%Convention includes following parts of version number: prefix, first version compound, second version compound, third version compound, fourth version compound, suffix label, suffix number. 
%Script that parses version numbers allows for following separators between different version number compounds: '.' (period), '-' (dash), '\_'(underscore), ' ' (space). 
%You can find examples of version number parsing results in Table \ref{table:exampleVCs}. Also we distinct between numeric version compounds and textual version compound. Numeric version compounds appear in Table \ref{table:exampleVCs} in bold.


\section{State of the Practice}
\label{sec:Practice}

\TODO{This section}

Given a version number MAJOR.MINOR.PATCH, increment the:

MAJOR version when you make incompatible API changes,
MINOR version when you add functionality in a backwards-compatible manner, and
PATCH version when you make backwards-compatible bug fixes.
Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format.

\section{Metrics}

%{Why inconsistency is bad? Because it breaks existing assumptions.} 
We define inconsistency in software version numbering as an availability of choices for assigning new version number that breaks existing version numbering patterns. 
For example, if software development team released versions 1.0, 1.1 and 1.2, then, following the establish pattern, the next expected version of upcoming release would be 1.3. 
However,  the software development team in this example decided to assign version 2.0 to the next release instead.
%\TODO{Sometimes software development team decides to assign version 2.0 instead or assigning version 1.3}. 
If there is no communication between development team and external groups, deviating from the established version numbering pattern breaks the assumptions of other groups that rely on the software, such as the software testing team.
%Because the next version increases from 1.2 to 2.0, software testers and other teams dependent upon the software will make assumptions based on the broken broken pattern in the version numbering.
%This jump from 1.2 to 2.0 will break assumptions of software testing team about upcoming release. 
%In this particular scenario testers might make assumptions not only about version numbers. 

Increasing a version compound on the left such as from 1.2 to 2.0 usually indicates that the new release includes some important or large scale changes. Because the version number increased to 2.0 instead of 1.3 in the above example,  the software testing team suddenly expects to perform additional work to accommodate the supposedly larger changes (e.g., a large number of features to be tested, new test-suites to be created, test-plan to be updated, etc).
%\feedback{you lost me after this. What if there was a big change and the tester did need to do a lot of work?} 
Thus, a simple change of version number might lead to confusion and misunderstanding between members of a software team.
%This is a simple example of ..... 

\TODO{To summarize, inconsistent version numbers have potential to break assumptions about established software development processes. }

We define the severity of inconsistency as the \numberchoices that are available for a 
given project. The following examples illustrate scenarios of version numbering that strictly adhere to the current state of the practice, described in 
Section~\ref{sec:Practice}.\\

\TODO{Example Diagram}

\MyParagraph{Example 1} A software team working on a project with existing versions 1.0, 1.1, 1.2 has two possible choices of assigning a new version number to the upcoming release: 1.3 or 2.0. 
In this example, the software development team is using only two version compounds. \\
% The first such property is \textbf{number of version compounds}. 

\MyParagraph{Example 2} A software team working on a project with existing versions 1.0.0, 1.0.1, 1.0.2 has three possible choices of assigning a new version number to the upcoming release. The choices are: 1.0.3, 1.1.0, or 2.0.0. 
In this example, the software development team is using three version compounds. \\

%Second property that defines number of possible choices for new version numbers is \textbf{number of "locked in" versions}. 

\MyParagraph{Example 3} 
Consider a software team that can release an update for either the latest version or an older version. Suppose that their project has the existing versions 1.0, 1.1, 1.2, 2.0, 2.1, 3.0. The team has four choices: 1.3 or 2.2 (as updates to older versions), and 3.1 or 4.0 (as updates to the latest version). 
Notice that the team cannot select version 2.0 for release as an update to 1.2 
because version 2.0 already exists. 
Similarly, the team cannot select version 3.0 for release as an update to 2.1 because version 3.0 already exists. \\

\MyParagraph{Example 4}  A software team  is working on a project with existing versions 1.0.0, 1.0.1, 1.0.2, 2.0.0, 2.1.0, 3.0.0. 
The team has now eight choices of assigning a new version number to the upcoming release: 
1.0.3, 1.1.0, 2.0.1, 2.1.1, 2.2.0, 3.0.1, 3.1.0, 4.0.0. 
In this case, the software team has the option to use three version compounds and the option to build off of older releases. \\

\TODO{rename the labels of examples so that they are revealing the essence of the example -- this will be easier for the reader on later pages to remember the example}

\TODO{can you find a real example to illustrate the scenarios above}

\TODO{Why these are valid examples and the state of the practice}

In Examples 3 and 4 the option of building on older versions stems from the need to support users that are unable or unwilling to use the latest release.\\

\MyParagraph{Version Number Trees}
% why version trees
So far, in the Examples 1--4 we have used lists of version numbers. To make it easier to understand and visualize the number of available choices for assigning a new version number, we introduce a new abstraction, version number trees.

% what are version trees
Version number trees are trees where the parent nodes are version numbers with trailing zeroes. A child node is a version number that has common leading version compound values with its parent, and at least one less trailing zero than its parent.
Figure~\ref{fig:diaExamples} shows the version trees for the lists of versions from Examples 1--4.

% how we construct version trees
%First we create nodes of the version numbers from the lists that have the highest number of trailing zeros. 
To construct a version tree from an existing version number list we perform the following operations.
First we traverse a version number list to find the version numbers with the highest number of trailing zeros.
Once we have found the version numbers with the highest number of trailing zeros, we add them to the version tree as parent nodes.
Then we find all the version numbers that have one less trailing zero and attach them as a child node to a parent node that has the same values of leading version compounds.
We repeat the previous step until we have traversed all elements in the version number list and added them to our version number tree.


%\TODO{Explain how to go from lists --$\rangle$ trees} \\



\MyParagraph{Version Number MetaTrees}
% why metatrees
Examples 1--4 show that there are several choices for assigning the next version numbers. To be able to represent compactly and to compute the \numberchoices for an arbitrary list of existing versions, we introduce a new abstraction called a \emph{metatree}. 

%\TODO{This paragraph is confusing-- rephrase}. Metatrees include information about (1) values of version compounds that are common for a set of version numbers, (2) implicitly considers the unique values of version compounds, represented by the placeholder 'x', and (3) preserves the number of version compounds present in the version numbers. 

% what are metatrees
In order to define metatrees, we first define \emph{version sets}.
A version set represents a list of versions that have common leading version compound values. For example, the list of versions 1.0, 1.1, 1.2, $\dots$, 1.N 
form the version set 1.x, where ``x'' is a placeholder.
This representation can be expanded to include additional version compounds. 
For example the version set 1.x.x represents the set of version sets 1.0.x (including 1.0.0, 1.0.1, 1.0.2, $\dots$, 1.0.N), 1.1.x (including 1.1.0, 1.1.1, 1.1.2, $\dots$, 1.1.N),  $\dots$, 1.M.x (including 1.M.0, 1.M.1, 1.M.2, $\dots$, 1.M.N). As shown in Diagram \ref{diaVersionSet}.

Finally, x.x.x represents the super set of version sets in the above example, including sets of version sets 1.x.x, 2.x.x, $\dots$, K.x.x.
In a metatree, the root is the superset of version sets and represents all possible version numbers with the same number of version compounds.


\TODO{Version Set Diagram}



Version number metatrees are trees where the parent nodes are version sets with trailing placeholders. A child node is a version set that has common leading version compound values with its parent, and at least one less trailing placeholder than its parent. For example, version set 1.x.x is the parent to version sets 1.0.x, 1.1.x, $\dots$, 1.M.x.  Similarly, x.x.x is the parent of version sets 1.x.x, 2.x.x, $\dots$, K.x.x.  
Table \ref{tabMetatrees} contains examples of valid metatrees.


\begin{table}
\begin{tabular}{c c c }
\begin{minipage}{.3\columnwidth}
\dirtree{%
.1 x.x.
.2 1.x.
.2 2.x.
}  
\end{minipage} &
\begin{minipage}{.3\columnwidth}
\dirtree{%
.1 x.x.x.
.2 1.x.x.
.3 1.0.x.
.2 2.x.x.
}  
\end{minipage} &
\begin{minipage}{.3\columnwidth}
\dirtree{%
.1 x.x.x.
.2 1.x.x.
.3 1.0.x.
.3 1.1.x.
.2 2.x.x.
.2 3.x.x.
}  
\end{minipage} 
\end{tabular}
\caption{Examples of metatrees}
\label{tabMetatrees}
\end{table}


% how we construct metatrees

We construct metatrees using the parent-child relationships of the version sets.
Figure~\ref{fig:diaExamples} shows the metatrees for the lists of versions from Examples 1--4. 

\feedback{Number steps???}
To construct a metatree from an existing version number list we perform the following operations.
First we identify all of the version sets that exist within a version number list and put them in a list of version sets.
For example the version number 1.2.3.4 belongs to the version sets 1.x.x.x, 1.2.x.x, and 1.2.3.x. 
A version number belongs to a version set if it has common leading version compound values.
When we form the version sets, we account for the possibility that a version number can be placed in multiple version sets and can add up to one less than the number of version compounds per version number.
\feedback{help us}

Then we add the superset of version sets as the root node for the metatree.
Next we traverse a version set list to find the version numbers with the highest number of placeholders.
Once we have found the version sets with the highest number of placeholders, we add them to the metatree as children of the root.
Then we find all the version sets that have one less placeholder and attach them as a child node to a parent node that has the same values of leading version compounds.
We repeat the previous step until we have traversed all elements in the version set list and added them to our metatree.

%\TODO{1. Explain how to see number of choices, 2. explain how metatrees show this, 2a. Explain throwing away the most recent}

We  created metatrees to help us calculate the \numberchoices which are difficult to compute when only looking at a version number list or a version number tree.

In Example 1, a software team's existing versions are 1.0, 1.1, 1.2 with the two choices 1.3 and 2.0 for the next release. As Figure~\ref{fig:diaExamples} shows, we can extract two version sets from the existing list of version numbers: x.x and 1.x. The version set 1.x accounts for the choice to change from 1.2 to 1.3 because both have a 1 as a leading version compound. The version set x.x accounts for the change from 1.0 to 2.0 because the two version numbers have similar structure, but no common version compounds.

% The first such property is \textbf{number of version compounds}. 

In Example 2, a software team working on a project with existing versions 1.0.0, 1.0.1, 1.0.2 with the three choices 1.0.3, 1.1.0, or 2.0.0. 
As Figure~\ref{fig:diaExamples} shows, we can extract three version sets from the existing list of version numbers: x.x.x,1.x.x, and 1.0.x. 
The version set 1.0.x accounts for the change from 1.0.2 to 1.0.3 because both version numbers have common values for the first two version compounds. 
The version set 1.x.x accounts for the choice to change from 1.0.0 to 1.1.0 because both have a 1 as a leading version compound. 
The version set x.x.x accounts for the change from 1.0.0 to 2.0.0 because the two version numbers have similar structure, but no common version compounds.


%Second property that defines number of possible choices for new version numbers is \textbf{number of "locked in" versions}. 

In Example 3, a software team's project has the existing versions 1.0, 1.1, 1.2, 2.0, 2.1, 3.0. The team has the four choices 1.3, 2.2, 3.1, and 4.0 
As Figure~\ref{fig:diaExamples} shows, we can extract three version sets from the existing list of version numbers: x.x, 1.x, 2.x, and 3.x. 
The version set 1.x accounts for the change from 1.2 to 1.3, the version set 2.x accounts for the change from 2.1 to 2.2, and the version set 3.x accounts for the change from 3.0 to 3.1 because the version numbers have common values for the first version compounds. 
The version set x.x accounts for the change from 3.0 to 4.0 because the two version numbers have similar structure, but no common version compounds.


In Example 4, a software team's project has the existing versions 1.0.0, 1.0.1, 1.0.2, 2.0.0, 2.1.0, 3.0.0.
 The team has the eight choices 1.0.3, 1.1.0, 2.0.1, 2.1.1, 2.2.0, 3.0.1, 3.1.0, 4.0.0 for the next assigned version number. 
As Figure~\ref{fig:diaExamples} shows, we can extract eight version sets from the existing list of version numbers: x.x.x, 1.x.x, 1.0.x, 2.x.x, 2.0.x, 2.1.x, 3.x.x, and 3.0.x. 
The version set 1.0.x accounts for the change from 1.0.2 to 1.0.3, the version set 2.0.x accounts for the change from 2.0.1 to 2.0.2, and the version set 3.0.x accounts for the change from 3.0.0 to 3.0.1 because the version numbers have common values for the first version compounds. 
The version set 1.x.x accounts for the change from 1.0.0 to 1.1.0, the version set 2.x.x accounts for the change from 2.0.0 to 2.1.0, and the version set 3.x.x accounts for the change from 3.0.0 to 3.1.0 because the version numbers have common values for the first two version compounds. 
The version set x.x.x accounts for the change from 3.0.0 to 4.0.0 because the two version numbers have similar structure, but no common version compounds.

As you can see from the four examples above, the \numberchoices is equal to the number nodes in a metatree.

 
%In order to extract essential information from version number lists into version number patterns we consolidate version numbers into a single version set based on common values of version compounds.
%For example, we consolidate both version numbers 2.0.1 and 2.0.2 to the single version set 2.0.x because the common part of the two version numbers is 2.0.
% Likewise, we consolidate version numbers 3.1.0, 3.5.0, and 3.2.3 into version set 3.x.x because the common part of the three version numbers is 3.



%We put version numbers from the lists of version numbers in groups for easier visual recognition of patterns. 
%The groups are determined by how many zeros are to the right of the last non-zero version compound and are organized by the farthest right non-zero version compound. 
%We organize these groups into a tree structure to represent the potential for simultaneous releases of both old versions and the latest version, as described in Example 3 and 4. Diagram \ref{diaExamples} contains examples of mapping from a list of version numbers to a tree of version numbers.
 



\TODO{MetaTrees Diagram (one for each of the 4 examples before)}

\input{examplesFigure.tex}




%In this case we consider set of versions 1.x (1.0, 1.1, 1.2) and 2.x (2.0, 2.1) to be "locked in" because one of the choices for new version numbers is unavailable.

In order to analyze the degree of inconsistency in version numbers, we define 
a set of metrics that measure common features of version numbers sequences. Different metrics establish typical cases that introduce additional choices for version numbering. \\
 
 
 %T\TODO{How to determine the number of choices}
 
 %\TODO{END OF DAY: 0. 1. Check Version history to metatree mapping. 2. Explain throwing away the latest metatree nodes and why and how metatrees affect choices. 3. Check Explain placeholder. 4. explanation of metrics in terms of metatrees. 5. Party like its 1999. }
 
\MyParagraph{Jumps}. A \emph{jump} is defined by two consecutively released versions when a version compound increases by more than one.
For example, one project where version 1.0.25 is followed immediately by version 1.0.28 represents one jump in the third version compound. This jump's size is 3. Jumps introduce more \choices which indicate more inconsistencies in version number. 
Jumps can introduce immediate and implicit choices.

An \emph{immediate choice} is a \choice that can result from incrementing an existing version number by one. 
An \emph{implicit choice} is a \choice that can result from incrementing an existing version number by two or more.
The difference between an immediate choice and an implicit choice is that an implicit choice is unavailable incrementally from the existing version numbers. 
In the example above, version number choice 1.0.26 and the new version number choice 1.0.29 are immediate choices and the version number choice 1.0.27 is an implicit choice.
\\
%Jumps represent inconsistencies in version numbering and can cause confusion.
 
%\begin{itemize}
\MyParagraph{\textbf{Number of jumps}}.  For each version compound of a project, this metric counts the total number of jumps across all versions. For example, in a project where one jump happens from version 1.0.25 to 1.0.28, and another jump happens from 1.0.34 to 1.0.40 will register as two jumps in the third version compound.
We collect the number of jumps it indicates the frequency that the problem of jumping version numbers arises. 
The number of jumps also indicates the number of immediate choices introduced by jumps.\\

\MyParagraph{\textbf{Sum of jumps}}.  For each version compound of a project, this metric counts the sum of all sizes of jumps within that compound. 
In the example above, the length of jump on the third version compound is 
9 ( 3 + 6). Whereas the previous metric records whether jumps occurred, this metric records the severity of the jumps. 
The sum of the size of all jumps can be used to calculate the \numberchoices that have been added as a result of jumping.
For example, in the project above the jump from version 1.0.25 to 1.0.28 introduces the immediate choice 1.0.29 in addition to an implicit version choice, 1.0.27, for a total of two extra \choices.

In the jump from version number 1.0.34 to 1.0.40 in the above example one immediate choice is added and four implicit choices are added for a total of five additional choices.
Thus, the size of a jump relates to the number of additional choices as one less than the size of the jump.
Using the sum of the jumps and the total number of jumps, we calculate the total \numberchoices as the sum of all jumps minus the number of jumps.\\

 
\MyParagraph{\textbf{Average size of jumps}}. For each version compound of a project, this metric calculates average of  jump sizes within that compound. 
For the example above, the average jump size for the third version compound is 4.5 ( $\frac{ 3 + 6 }{2}$).
The average size of jumps represents the average \numberchoices introduced by each jump.

 
 %\textbf{List of jumps.} We consider every change in numeric version compound to be a jump if difference between version compound values appear to be greater than 1. Examples: 1 to 3, 5 to 10. 
%\begin{equation}
%VC_{2} - VC_{1} > 1
%\end{equation}

%\end{itemize}

%We collect length of each jump for further analysis. For example list of jumps for third version compound for array of version numbers [1.0.2, 1.0.3, 1.0.5, 1.0.6, 1.0.7, 1.0.10] would be [2, 3]. 

\MyParagraph{Empty Jumps}. An empty jump is defined by two consecutively released versions containing a different number of version compounds. 
For example, one project where version 1.0.25 is followed immediately by version 1.1 represents an empty jump in third version compound, later in this project another empty jump happens from version 1.3 to 1.3.1. 
We distinguish between adding or removing version compounds because shrinking or expanding the version number will have a different effect on the \numberchoices. 
When removing version compounds, the \numberchoices increases by the number of version compound in the new version number. In the above example, shrinking the version number from 1.0.25 to 1.1 introduces three new \choices, 1.2 and 2.0 in addition to the existing \choices, 1.0.26, 1.1.0 and 2.0.0. 
When expanding the version number to include additional version compounds, the \numberchoices also increases by the number of version compound in the new version number. In the above example, expanding the version number from 1.3 to 1.3.1 introduces three new \choices, 1.3.2, 1.4.0, and 2.0.0 in addition to the existing \choices, 1.4 and 2.0. \\
%We do not distinguish between adding or removing version compounds because either expanding or shrinking the version number demonstrates a lack of consistency. \TODO{address textual stuff?} \\

%\begin{itemize}


\MyParagraph{\textbf{Number of empty jumps}}.  For each version compound of a project, this metric counts the total number of empty jumps across all versions. For example, in a project where one jump happens from version 1.0 to 1.0.1, and another jump happens from 1.0.34 to 1.1 will register as two.
We do not collect the number of version compounds added or removed in this metric.
We collect the number of empty jumps because they indicate the frequency that the problem of empty jumping in version numbers arises. \\

\MyParagraph{\textbf{Sum of the severity of empty jumps}}.  For each time an empty jump occurs, this metric counts the total number of version compound that have been added for removed from the version number list. 
Each time an empty jump occurs we compute the severity of the empty jump as the number version compounds present in the second version number of the empty jump.
In the example above the severity of the empty jump from version number 1.0 to version number 1.0.1 is three.
Similarly, the severity of the empty jump from version number 1.0.34 to version number 1.1 is two.
Therefore, the sum of the severities for both empty jumps is five.
We use the sum of all empty jumps to calculate the total \numberchoices introduced due to empty jumps. \\

 
\MyParagraph{\textbf{Average size of severity}}. 
This metric calculates average \numberchoices introduced all empty jumps in the version number list. For the example above, the average \numberchoices introduced by all empty jumps is 2.5 ( $\frac{ 2 + 3}{2}$).
 \\




%\MyParagraph{\textbf{Number of empty jumps}}. For each version compound of a project, this metric counts the sum of all occurrences of empty jumps throughout each version compound.
%For example, both 1.0.25 to 1.1 and 1.3 to 1.3.1 are empty jumps in third version compound \feedback{(an empty jump in the second and third version compounds, respectively | two empty jumps in the third compound)}. \\
%%for each numeric version compound. We consider change of numeric version compound to be an empty jump if empty value substitutes numeric value of version compound. For example, there is an empty jump of fourth version compound for the pair of version numbers [1.0.2.4, 1.0.3]. \\
%
%\MyParagraph{\textbf{Sum of empty jumps}}. For each version compound of a project, this metric counts the sum of all occurrences of empty jumps throughout each version compound.
%For example, both 1.0.25 to 1.1 and 1.3 to 1.3.1 are empty jumps in third version compound \feedback{(an empty jump in the second and third version compounds, respectively | two empty jumps in the third compound)}. \\
%
%\MyParagraph{\textbf{Average Severity of empty jumps}}. For each version compound of a project, this metric counts the sum of all occurrences of empty jumps throughout each version compound.
%For example, both 1.0.25 to 1.1 and 1.3 to 1.3.1 are empty jumps in third version compound \feedback{(an empty jump in the second and third version compounds, respectively | two empty jumps in the third compound)}. \\


%
%\begin{equation}
%\begin{split}
%isNumeric(VC_{1}) \&\& isEmpty(VC_{2})  || \\  
%isNumeric(VC_{2}) \&\& isEmpty(VC_{1})
%\end{split}
%\end{equation}

 
\MyParagraph{\textbf{Instances of Megalomania}}. Megalomania is defined as electing to increment a version compound to the left of the rightmost version compound when assigning the next version number.
For example a developer might think about two ways of incrementing version 1.0 if he or she needs to come up with a version number for the next release.
 As far as most of the existing conventions describe [LINKS], first way is to assign version 1.1 to new release. Second way is to assign version 2.0. Note that second approach uses increment of first version compound instead of incrementing rightmost version compound, this is an example of megalomania. 

Megalomania introduces new \numberchoices.
In Example 2, a software team working on a project with existing versions 1.0.0, 1.0.1, 1.0.2 with the three \choices 1.0.3, 1.1.0, or 2.0.0. 
Here, choosing either version number 1.1.0 or version number 2.0.0 would result in an instance of megalomania because both of these choices introduce one or more \choices to the existing \choices. \\


%Developers introduce potential for megalomania by using more than one version compound in the version number. We use instances of megalomania as indicators of potential for arbitrary decisions related to version numbering. 
% \feedback{Why is this important?}
%We consider this case of assigning next version number (incrementing version compounds on the left side instead of rightmost version compound) to be instance of megalomania. 

%Other examples of megalomania: $$ 1.0.2 \rightarrow 2.0.0 \texttt{, } 1.4.5 \rightarrow 1.5.0 $$

%\MyParagraph{Severity of Megalomania} 
%\TODO{Define severity} 

%There are N-1 possible cases of assigning new version to the version number with N numeric version compounds. We distinct between different ways of assigning version numbers depending on position of incremented numeric version compound. 
%
%For example we consider change of version 1.0 to 2.0 to be megalomania of severity 1, 1.0.0 to 2.0.0 to be megalomania of severity 2 and change of version 1.0.0.0 to 2.0.0.0 to be megalomania of severity 3.
%
%change of version 1.0.4\_p34 to 1.1.0 to be megalomania of severity 2, etc. In most general case, we consider changing 1st numeric version compound in version with N numeric version compounds to be megalomania of severity N-1, 2nd numeric version compound in version with N numeric version compounds to be megalomania of severity N-2, and so on. 

%We collect information about megalomania severity as another metric. For example, list of megalomania severities for list of versions [1.0.0, 1.0.1, 1.0.2, 1.1.0, 1.1.1, 1.2.0, 1.2.1, 2.0.0] would be [1,1,2].
%
%We calculated metrics both for each version compound and aggregated values to represent metrics for  version number.
%\end{itemize}

\MyParagraph{\textbf{Number of instances of megalomania}}.  
This metric counts the total number of instances of megalomania across all versions in a version number list.
For example, in a project where version numbers increase from version 1.0.1 to 2.0.0, and later from 2.0.25 to 2.1.0 will register as two instances of megalomania.
We collect the number of instances of megalomania because they indicate the frequency that the problem. \\

\MyParagraph{\textbf{Sum of the severity of megalomania}}.  
Notice that there is a difference between change from 1.0.0 to 1.1.0 and change from 1.0.0 to 2.0.0. 
The change from 1.0.0 to 1.1.0 introduces one additional \choice while the change from 1.0.0 to 2.0.0 introduces two more \choices.
We use this to define the severity of megalomania as the \numberextrachoices introduced by instance of megalomania.
\feedback{i hate this sentence} We take the sum of the severities of megalomania for every instance encountered in  the version number list.
In the example above, the sum of the severities of megalomania is 3 (1 + 2).
We use the sum of all instances of megalomania to calculate the total \numberchoices introduced due to megalomania. \\

 
\MyParagraph{\textbf{Average severity of megalomania}}. 
This metric calculates average \numberchoices introduced all instances of megalomania in the version number list. For the example above, the average \numberchoices introduced by megalomania is 1.5 ( $\frac{ 1 + 2}{2}$).
 \\


\subsection{Metrics and Metatrees}

We are connecting metrics with operations on metatrees.

We are doing this to prove that metatrees are useful.

\MyParagraph{Jumps and Metatrees}
Jumps and metatrees don't like each other because jumps happen within version sets. 
Therefore it does not introduce a change to the metatree.
We collect these because they are still inconsistencies but they are not high level inconsistencies. \\

\MyParagraph{Empty Jumps and Metatrees}
What: We are showing that the inconsistencies caused by empty jumps can be represented by operations on metatrees.
Why to show that we can predict inconsistencies caused by empty jumps
How: We represent empty jumps as the union of two metatrees. 
For example, there is a project where one jump happens from version 1.0 to 1.0.0. 
\TODO{Figure}
Figure~\ref{fig:empty2VC} shows the metatree for each versions' individual metatree and the union of both trees. \\

\MyParagraph{Megalomania and Metatrees}
What:  We are showing that the inconsistencies caused by megalomania can be represented by operations on metatrees.

Why: to show that we can predict inconsistencies caused by megalomania

How: 
We represent megalomania as new nodes of the metatree.
For example, in a project that contains two instances of megalomania, from version 1.0.1 to 2.0.0, and later from 2.0.25 to 2.1.0.
\TODO{show that there are 2 nodes for the first megalomania and 1 node for the second megalomania}


\section{Analysis}

\begin{itemize}
\item RQ1: OSS vs Proprietary
\item RQ2: Projects of different sizes
\item RQ3: Age of different projects
\item RQ4: Dev tools vs other applications
\item RQ5: SDKs vs other applications 
\end{itemize}


\section{Implications}

\section{Threats to Validity}

 The proprietary data may be incomplete because we only harvested information that the distributor chose to display online which could contribute to additional jumps for artifacts that were never made public. Conversely, enterprises may shield the general from the burden of intermediate builds by only displaying clean, sequential versions on their websites and in their documentation which could skew the results of our analysis.



\section{Related Work}

Marquardt~\cite{Marquardt2010:EuroPLoP} describes patterns for software release versioning ...


\section{Conclusions}


\section*{Acknowledgments}

The authors would like to thank...

%
% The following two commands are all you need in the
% initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
\bibliographystyle{IEEEtran}
\bibliography{bibliography}  % sigproc.bib is the name of the Bibliography in this case

\end{document}
